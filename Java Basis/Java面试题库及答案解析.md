# Java面试题库及答案解析

## 1、面向对象编程（OOP）有哪些优点？

* 代码开发模块化，更易维护和修改。
* 代码复用。
* 增强代码的可靠性和灵活性。
* 增加代码的可理解性。

## 2、面向对象编程有哪些特性？

封装、继承、多态、抽象

### 封装

封装给对象提供了隐藏内部特性和行为的能力。对象提供一些能被其他对象访问的方法来改变它内部的数据。在Java当中，有3种修饰符：public，private和protected。每一种修饰符给其他的位于同一个包或者不同包下的对象赋予了不同的访问权限。

下面列出了使用封装的好处：

* 通过隐藏对象的属性来保护对象内部的状态。
* 提高了代码的可用性和可维护性，因为对象的行为可以被单独的改变或者是扩展。
* 禁止对象之间的不良交互提高模块化。

### 继承

继承给对象提供了从基类获取字段和方法的能力。继承提供了代码的重用，也可以在不修改类的情况下给现存的类添加新特性。

### 多态

多态是编程语言给不同的底层数据类型做相同的接口展示的一种能力。一个多态类型上的操作可以应用到其他类型的值上面。

### 抽象

抽象是把想法从具体的实例中分离出来的步骤，因此，要根据他们的功能而不是实现细节来创建类。Java支持创建只暴露接口而不包含方法实现的抽象的类。这种抽象技术的主要目的是把类的行为和实现细节分离开。

## 3、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。

Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。

## 4、JDK和JRE的区别是什么？

JRE(Java运行时环境) 是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。JDK(Java开发工具包) 是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者 开发、编译、执行Java应用程序。

## 5、”static”关键字是什么意思？Java中是否可以覆盖(override) 一个private或者是static的方法？

“static”关键字表明一个成员变量或者是成员方法可以在没有所属的类的实例的情况下被访问。

Java中static方法不能被覆盖，因为方法覆盖是基于运行时动态绑定的，而static方法是编译时静态绑定的。static方法跟类的任何实例都不相关，所以概念上不适用。

## 6、是否可以在static环境中访问非static变量？

static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。

## 7、Java支持的数据类型有哪些？什么是自动拆装箱？

Java支持的基本数据类型有：

* byte
* short
* int
* long
* float
* double
* boolean
* char

自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。比如：把int转化成Integer。反之就是自动拆箱。

## 8、Java中的方法覆盖(Overriding)和方法重载(Overloading)是什么意思？

Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。而方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。

## 9、Java中，什么是构造函数？什么是构造函数重载？什么是复制构造函数？

当新对象被创建的时候，构造函数会被调用。每一个类都有构造函数。在程序员没有给类提供构造函数的情况下，Java编译器会为这个类创建一个默认的构造函数。

Java中构造函数重载和方法重载很相似。可以为一个类创建多个构造函数。每一个构造函数必须有它自己唯一的参数列表。

Java不支持像C++那样的复制构造函数，这个不同点是因为如果你不自己写构造函数的情况下，Java不会创建默认的复制构造函数。

## 10、Java支持多继承么？

不支持，Java不支持多继承。每个类都只能继承一个类，但是可以实现多个接口。

## 11、抽象类和接口的区别是什么？

Java支持创建抽象类和接口。它们的区别在于：

* 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。

* 类可以实现很多个接口，但是只能继承一个抽象类

* 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不实现抽象类声明的所有方法，在这种情况下，类也必须得声明成是抽象的。

* 抽象类可以在不提供接口方法实现的情况下实现接口。

* Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。

* Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。

* 接口是绝对抽象的，不可以被实例化。抽象类也不可以被实例化，但是，如果它包含main方法的话是可以被调用的。

## 12、什么是值传递？什么是引用传递？

对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。

对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。

## 13、进程和线程的区别是什么？

进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

## 14、创建线程有几种不同的方式？你喜欢哪一种？为什么？

创建线程有以下几种方式：

* 继承Thread类

* 实现Runnable接口

* 应用程序可以使用Executor框架来创建线程池

实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在已经继承了别的类的情况下，这需要多继承（而Java不支持多继承），只能实现接口。同时，线程池也是非常高效的，很容易实现和使用。

## 15、解释一下线程的几种可用状态

线程可以处于以下几种状态：

* 就绪(Runnable)：线程准备运行，不一定立马就能开始执行。

* 运行中(Running)：进程正在执行线程的代码。

* 等待中(Waiting)：线程处于阻塞的状态，等待外部的处理结束。

* 睡眠中(Sleeping)：线程被强制睡眠。

* I/O阻塞(Blocked on I/O)：等待I/O操作完成。

* 同步阻塞(Blocked on Synchronization)：等待获取锁。

* 死亡(Dead)：线程完成了执行。

## 16、同步方法和同步代码块的区别是什么？

在Java语言中，每一个对象都有一把锁。线程可以使用synchronized关键字来获取对象上的锁。synchronized关键字可应用在方法级别(粗粒度锁)或者是代码块级别(细粒度锁)。

## 17、在监视器(Monitor)内部，是如何做线程同步的？程序应该做哪种级别的同步？

监视器和锁在Java虚拟机中是一起使用的。监视器监视同步代码块，确保一次只有一个线程执行同步代码块。每一个监视器都和一个对象引用相关联。线程在获取锁之前不允许执行同步代码。

## 18、什么是死锁(deadlock)？

两个线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个线程都陷入了无限的等待中。

## 19、如何确保N个线程可以访问N个资源同时又不导致死锁？

使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。

## 20、Java集合类框架的基本接口有哪些？

Java集合类里面最基本的接口有：

* Collection：代表一组对象，每一个对象都是它的子元素。

* Set：不包含重复元素的Collection。

* List：有顺序的Collection，并且可以包含重复元素。

* Map：可以把键(key)映射到值(value)的对象，键不能重复。

## 21、为什么集合类没有实现Cloneable和Serializable接口？

克隆(cloning)或者是序列化(serialization)的语义和含义是跟具体的实现相关的。因此，应该由集合类的具体实现来决定如何被克隆或者是序列化。

## 22、什么是迭代器(Iterator)？

Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。

## 23、Iterator和ListIterator的区别是什么？

他们的区别如下：

* Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。

* Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。

* ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。

## 24、快速失败(fail-fast)和安全失败(fail-safe)的区别是什么？

Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。

## 25、Java中的HashMap的工作原理是什么？

Java中的HashMap是以键值对(key-value)的形式存储元素的。HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合添加元素和从集合检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。

HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。

## 26、hashCode()和equals()方法的重要性体现在什么地方？



















---

本文永久更新地址：[https://github.com/nnngu/LearningNotes/blob/master/Java%20Basis/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93%E5%8F%8A%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md](https://github.com/nnngu/LearningNotes/blob/master/Java%20Basis/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E5%BA%93%E5%8F%8A%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90.md)