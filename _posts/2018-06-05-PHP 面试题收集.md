---
categories: Interview
description: PHP 面试题收集
---

## 1、觅蓝

### 1、数据库索引，复合索引，唯一索引，哪些地方用到？

**建立索引：**
```
格式：
create index 索引名 on 表名 (列名);
例子：
create index index_name on users (name);
```

**复合索引：**

- 单一索引是指索引列为一列的情况,即新建索引的语句只实施在一列上;     
- 用户可以在多个列上建立索引,这种索引叫做**复合索引(组合索引)**;     
- 复合索引在数据库操作期间所需的开销更小,可以代替多个单一索引;

> 参考：[复合索引的优点和注意事项](https://www.cnblogs.com/summer0space/p/7247778.html)

**唯一索引：**

Unique Index 就是额外添加的唯一性约束。该约束严格的保证索引列的取值唯一性。例如：用户邮箱、用户的手机号需要唯一索引

**聚簇索引：**

聚簇索引的索引顺序与数据库的物理存储顺序一致，并且一个表只能有唯一的一条聚簇索引。

> 参考：[和刚入门的菜鸟们聊聊--什么是聚簇索引与非聚簇索引](https://www.cnblogs.com/auxg/p/Cluster-and-NonCluster-index.html)

**非聚簇索引：**

非聚簇索引的索引顺序与数据库的物理存储顺序没有必然联系，一个表可以有多个非聚簇索引。

**用到索引的地方：**

* 根据商品的分类来查询商品时，在商品表里面的商品分类字段建立索引
* ~~根据订单的状态来查询订单时~~（在出现大量重复值的字段建立索引将不会有什么帮助；相反，还有可能降低数据库的性能）
* 根据文章的分类来查询文章时，在文章表里面的文章分类字段建立索引
* 根据文章的发布日期来查询文章时

**用到复合索引的地方：**

- 用户登录时，在数据库中查询账号和密码，用到复合索引。
- 商品的发布时间和商品的分类
- 文章的发布时间和文章的分类

### 2、数据库 char，varchar 的区别

char 的长度是固定的。而 varchar 的长度是自动调整的，也就是说，定义一个 char(10) 和 varchar(10)，如果存进去的是 ‘csdn’，那么 char 所占的长度依然为 10，除了字符 ‘csdn’ 外，后面跟六个空格，而 varchar 就立马把长度变为 4 了，取数据的时候，char 类型的要用 trim() 去掉多余的空格，而  varchar 是不需要的，尽管如此，char 的存取速度还是要比 varchar 要快得多，因为其长度固定，方便程序的存储与查找；但是 char 也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率，而 varchar 是以空间效率为首位的。

例如：  
- 存储用户的手机号，用 char(11)  
- 存储用户的真实姓名，用 char(10)  
- 邮政编码，用 char(6)

>参考：[数据库中char与varchar类型的区别](https://www.cnblogs.com/Berryxiong/p/6248464.html)  
>[MySQL中char、varchar和text的区别](https://www.cnblogs.com/xianDan/p/4292706.html)

### 3、各种数据库引擎的区别

- ISAM：查询速度快
- MyISAM：在 ISAM 的基础上增加了索引功能
- InnoDB：支持事务、支持外键。查询速度比前面两个引擎慢

在使用 MySQL 的时候，你所面对的每一个挑战几乎都源于 ISAM 和 MyISAM 数据库引擎不支持事务处理（transaction process）也不支持外来键。尽管要比 ISAM 和  MyISAM 引擎慢很多，但是InnoDB包括了对事务处理和外键的支持，这两点都是前两个引擎所没有的。

**MyISAM与InnoDB的区别**

InnoDB 和 MyISAM 基本的差别为：MyISAM 类型的表强调的是性能，其执行速度比 InnoDB 类型更快，但是不支持事务、外键等功能，而 InnoDB 支持事务、外键等功能。

**MyISAM适合：**

- 做很多 count 的计算
- 查询非常频繁、没有事务
- 例如：商品表、商品分类表、用户表

**InnoDB适合：**

- 要求事务、外键的地方
- 例如：订单表，订单的创建和订单的取消，需要用到事务

### 4、用到数据库事务的地方

很多地方都用到事务，数据的增删改都需要用到事务。

例如：  
- 例如订单的创建、订单的取消。  
- 生成订单、更新库存，如果失败了，需要回滚事务。

### 5、数据库的优化

- 使用索引
- 使用 char
- 适当的使用数据库引擎

>相关文章：[MySQL数据库优化的八种方式(经典必看)](https://www.cnblogs.com/zhyunfe/p/6209074.html)

### 6、数据库保存手机号用什么类型的字段

用 char(11)  

### 7、Redis 有哪些数据类型？

- string
- list
- set
- zset  (sorted set)
- hash  键值对集合(key=>value)

### 8、项目中哪些数据保存在 Redis ?

例如商品分类这种经常被查询又不经常改变的数据，保存在 Redis

### 9、ThinkPHP5 安全相关措施

- 预防 SQL 注入：使用 addslashes 函数(将'转为\\'，将"转为\\")
- 预防 XSS：使用 htmlspecialchars 函数将脚本标签的小于号转为\&lt; 大于号转为\&gt;
- 预防 CSRF：from 表单提交数据，使用 csrf token 验证
- public 目录是唯一的对外访问的目录
- 使用 TP 框架提供的 Request 类的 param 方法或者使用 input 助手函数来获取请求参数，而不是原生系统变量获取用户输入的数据

>参考：[官方文档-输入变量](https://www.kancloud.cn/manual/thinkphp5/118044)

### 10、秒杀用 Redis 队列？原子性

假设有10件库存，就往队列中push10个数。抢购开始后，每到来一个用户，就从队列中pop一个数，表示用户抢购成功。当列表为空时，表示已经被抢光了。因为 Redis 列表的pop操作是原子的，即使有很多用户同时到达，也是依次执行的。

上面的会导致一个用户抢多个，思路：   
需要一个排队队列(比如：queue:1,以user_id为值的列表)和抢购结果队列(比如：order:1,以user_id为值的列表)及库存队列(比如上面的goods_store:1)。高并发情况，先将用户进入排队队列，用一个线程循环处理从排队队列取出一个用户，判断用户是否已在抢购结果队列，如果在则已抢购，否则未抢购，接着执行库存减1，写入数据库，将此user_id用户同时也进入结果队列。


>参考：[redis实现高并发下的抢购/秒杀功能](https://www.cnblogs.com/phpper/p/7085663.html)

### 11、PHP 用存储过程会出现的问题

> 参考：  
> [MySQL存储过程详解和PHP操作示例](https://www.cnblogs.com/gxldan/p/4066914.html)  
> [mysql存储过程优缺点](https://blog.csdn.net/u014209975/article/details/52243295)

---

## 2、好品汇

### 1、索引是什么？主键和唯一索引的区别？索引的缺点？

索引就相当于一本书的目录，可以加快数据库的查询速度。

一张表只能有一个主键，但可以有多个唯一索引。

缺点：

- 索引在加快查询速度的同时也让插入和更新数据变慢，因为插入和更新数据时要修改索引结构
- 索引使用不当，有可能让速度变慢。例如：数据量很少的表就不用建立索引；
- 重复数据较多的字段就不应该建立索引，否则不仅没有加快查询速度，反而有可能让速度变慢。

### 2、什么是跨域？怎么解决跨域问题？

跨域是浏览器的一种安全机制（同源策略），是指网站的前端 javascript 禁止请求 不同域名、不同端口、不同协议的链接。

解决：

- 通过 jsonp 跨域 （原理：在页面上引用跨域的 js 脚本文件）
- 通过 php 等后端语言跨域

>参考：[js中几种实用的跨域方法原理详解](https://www.cnblogs.com/2050/p/3191744.html)

### 3、php 实现一个双向队列

```php
class Deque {  
    private $queue=array();  
      
    function addFirst($item){ //头入队  
        return array_unshift($this->queue,$item);  
    }  
    function addLast($item){ //尾入队  
        return array_push($this->queue,$item);  
    }  
    function removeFirst(){ //头出队  
        return array_shift($this->queue);  
    }  
    function removeLast(){ //尾出队  
        return array_pop($this->queue);  
    }  
    function show(){ //显示  
        echo implode(" ",$this->queue);  
    }  
    function clear(){ //清空  
        unset($this->queue);  
    }  
    function getFirst(){  
        return array_shift($this->queue);  
    }  
    function getLast(){  
        return array_pop($this->queue);  
    }  
    function getLength(){  
        return count($this->queue);  
    }  
} 
```

### 4、写出工作中遇到的一个难搞的 Bug，怎么解决？

Laravel 打开路由信息缓存时（`php artisan route:cache`），报错

解决：

- 打开路由信息缓存之后，路由文件里面不能有闭包的形式，要用控制器的形式
- 排查路由文件中的重复路由并修改。尤其要注意 `resource` 方法很可能导致与其他方法重复。

### 5、消息队列 RabbitMQ 的相关概念，初始化配置

* Broker：简单来说就是消息队列服务器实体。
* Exchange：消息交换机，它指定消息按什么规则，路由到哪个队列。
* Queue：消息队列载体，每个消息都会被投入到一个或多个队列。
* Binding：绑定，它的作用就是把 exchange 和 queue 按照路由规则绑定起来。
* Routing Key：路由关键字，exchange 根据这个关键字进行消息投递。
* vhost：虚拟主机，一个 broker 里可以开设多个 vhost，用作不同用户的权限分离。
* producer：消息生产者，就是投递消息的程序。
* consumer：消息消费者，就是接受消息的程序。
* channel：消息通道，在客户端的每个连接里，可建立多个 channel，每个 channel 代表一个会话任务。

消息队列的使用过程大概如下：
1. 客户端连接到 Broker 消息队列服务器，打开一个 channel。
2. 客户端声明一个exchange，并设置相关属性。
3. 客户端声明一个queue，并设置相关属性。
4. 在exchange和queue之间建立好绑定关系。
5. 客户端投递消息到exchange。
6. exchange接收到消息后，就根据消息的key和已经设置好的绑定，进行消息路由。

消息队列的持久化包括：
1. exchange持久化，在声明时指定durable => 1
2. queue持久化，在声明时指定durable => 1
3. 消息持久化，在投递时指定delivery_mode => 2（1是非持久化）

如果exchange和queue都是持久化的，那么它们之间的绑定也是持久化的。如果exchange和queue两者之间有一个持久化，一个非持久化，就不允许建立绑定。

> 参考：[初识RabbitMQ,附RabbitMQ+PHP演示实例](https://www.cnblogs.com/miketwais/p/RabbitMQ.html)

### 6、RabbitMQ 消息队列的应用场景、使用注意

应用场景：
* 对实时性要求不高、并且比较耗时的操作，放到消息队列里
* 用户注册时，发送注册短信、发送激活邮件 的消息放到消息队列里，异步处理
* 生成订单之后，更新库存的消息放到消息队列里

使用注意：
* 要把 no_ack 设置为 false，这样在接收到处理成功的 ack 通知之后才把消息队列里面的消息删除
* 消息队列 要设置持久化，防止丢失数据

>参考：
>[初识RabbitMQ,附RabbitMQ+PHP演示实例](https://www.cnblogs.com/miketwais/p/RabbitMQ.html)  
>[RabbitMq应用一的补充（RabbitMQ的应用场景）](https://www.cnblogs.com/saltlight-wangchao/p/6214334.html)

### 7、kafka、RabbitMQ、ActiveMQ 的区别

* kafka 的性能比较高、但是有可能会丢数据，所以在稳定性方面有所欠缺
* RabbitMQ 比较重量级、支持多种网络协议、支持数据持久化
* ActiveMQ 跟 RabbitMQ 类似，Java 语言用它用的比较多

>参考：[rabbitMQ、activeMQ、zeroMQ、Kafka、Redis 比较](https://www.cnblogs.com/valor-xh/p/6348009.html?utm_source=itdadao&utm_medium=referral)  

### 8、Redis 秒杀 ，商品库存队列用一个 String 存一个数字，通过数字的递减来减少库存

```php
public function buy($goods_id = 0){
	if(!$goods_id){
		die("商品不存在！");
	}
	$redis = new Redis();
	$redis->connect('127.0.0.1',6379);
	$stock = 0;
	if(!$redis->get("gid".$goods_id)){
		$stock = get_stock($goods_id); // 从数据库获取实际库存
		$redis->set("gid".$goods_id,$stock);
	}else{
		$stock = $redis->get("gid".$goods_id);
	}

	if($stock > 0){
		//逻辑操作（生成订单等操作）
		//coding here...
		
		// 更新库存
		$redis->set("gid".$goods_id,$stock-1);
	}else{
		die("已卖完！");
	}
}
```

### 9、Redis 的 List 是链表结构？

### 10、Redis 有哪些数据类型？

### 11、Memcached 和 Redis 的区别？

### 12、数据库引擎 MyISAM 为什么比 InnoDB 快？MyISAM 的存储结构？

### 13、多进程之间通讯的几种方式

### 14、分布式和集群的概念？区别？

### 15、微服务？

### 16、ThinkPHP 和 Laravel 的比较？

### 17、Laravel 的中间件 和 过滤器的区别？

### 18、Laravel 中间件 的前置处理，后置处理 

### 19、Laravel 的 IoC 和 DI ，DI 的实现原理 

### 20、MySQL 的范式和反范式

